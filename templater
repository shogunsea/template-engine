#! /usr/bin/env ruby

require 'debugger'
require 'json'


class TemplateEngine 
	attr_accessor :val

	def initialize
		@val = 100
	end

	def yolo
		puts @val
	end

end

# 3 arguments
# templater template.panoramatemplate data.json output.html

if ARGV.size != 3
	puts "Wrong arguments"
	exit 1
end

template_path, data_path, output_path = ARGV


# Robust, generic, recusive/iterative method.
# line object which contains children lines?.
# mapping between 'each' keyword and json/html

data = File.read data_path
output = File.open(output_path, "w");
 # parse json into hash object
parent_node = JSON.parse(data)

template_content = File.readlines template_path

# one mode of rendering:
# peek from current stack, use that
# element as current obj.
# EACH: push corresponding onto stack
# ENDEACH: pop that obj from stack.
stack = []
stack.push parent_node
index_stack = []
loop_start_index_stack = []
# !!!!TODO: Make these variables as instance attributes,
# 	add proper methods.
loop_start_index = 0
line = nil
new_line = nil
inner_line_index = 0
i = 0

while i < template_content.length
	line = template_content[i]

	if line.include? "<* EACH"
		# push current object onto stack
		# record total children size with procesed_items size
		# keep the starting index of current block

		# parse 'each' keyword
		key = line.scan(/EACH[^\*]*/).first.split(" ")[1]

		if key.include? '.'
			key = key.split(".").last
		end

		if stack.last.class == Array
			val = stack.last[index_stack.last][key]
		else
			val = stack.last[key]
		end

		index_stack.push 0
		stack.push val
		loop_start_index_stack.push (i + 1)


		new_line = "\n"
		output.write new_line
		i += 1

  	elsif line.include? "<* ENDEACH"
		# padding with empty line
		# check if total children size is equal to processed_items size
		# if so keep index going
		# else go back to record index

		# debugger
		if index_stack.last == stack.last.length - 1
			stack.pop
			index_stack.pop
			loop_start_index_stack.pop
			i += 1
		else
			index_stack[index_stack.size - 1] = index_stack.last + 1
			i = loop_start_index_stack.last
		end

		output.write "\n"

  	elsif line.include? "<*"
  		# fetch key from current hash object or array element.
  		# parse the current line

  		# Ensure keys should always be array
  		keys = line.scan(/<\*[^\*]*\*>/).first.split(" ")[1].split(".")

  		# debugger
  		if stack.last.class == Array
  			# If top of stack is Array
  			# pick last key
  			# process with inner_line_index
  			# 
  			# Val still can be either hash or elements!!
  			val = stack.last[index_stack.last]
  			# debugger
  			if val.class == Hash
  				keys.shift(keys.size - 1)
  				keys.each_with_index do |key, index|
	  			# 
	  				val = val[key]
	  			end
	  			output.write val
	  		else
	  			# array of string
	  			# val is a string
	  			output.write val
	  		end

  			# inner_line_index += 1
  			# ??
  			# Only Keep last keys
  			# student.name --> name
  			# student.name.lastname --> lastname
  		else 
  			# top of stack is hash
  			val = stack.last
  			keys.each_with_index do |key, index|
  			# 
  				val = val[key]
  			end
  			output.write val
  		end
  		i += 1
  	else
  		# do not need to be substitude.
  		output.write line
  		i += 1
    end
end


output.close




























